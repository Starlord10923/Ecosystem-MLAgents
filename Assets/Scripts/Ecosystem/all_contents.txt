

--- FILE: Agents\AgentAnimalBase.cs ---
using System.Collections.Generic;
using MEC;
using UnityEngine;

public abstract class AgentAnimalBase : AgentBase
{
    private CoroutineHandle currentConsumption;
    private Collider currentTarget = null;

    private CoroutineHandle matingCoroutine;
    private bool IsMating => matingCoroutine.IsRunning;

    protected virtual void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Wall"))
            RewardUtility.AddWallHitPenalty(this);

        CheckForConsumption(other);
        CheckForMating(other);
    }

    protected virtual void OnTriggerExit(Collider other)
    {
        if (currentTarget == other)
            StopCurrentConsumption();
    }

    public void CheckForConsumption(Collider other)
    {
        if (currentConsumption.IsRunning || !other.TryGetComponent<SustainedConsumable>(out var target))
            return;
        if (this is PreyAgent && target.consumableType == SustainedConsumable.Type.Prey)
            return;

        currentTarget = other;
        currentConsumption = Timing.RunCoroutine(ConsumeOverTime(target, other));
    }

    private void StopCurrentConsumption()
    {
        if (currentConsumption.IsRunning)
        {
            Timing.KillCoroutines(currentConsumption);
        }
        currentTarget = null;
    }

    private IEnumerator<float> ConsumeOverTime(SustainedConsumable target, Collider source)
    {
        float elapsed = 0f;

        while (elapsed < target.duration)
        {
            if (target == null)
            {
                StopCurrentConsumption();
                yield break;
            }

            float consumed = Mathf.Min(target.valuePerTick, target.remainingValue);
            if (consumed <= 0f)
            {
                StopCurrentConsumption();
                yield break;
            }

            switch (target.consumableType)
            {
                case SustainedConsumable.Type.Food:
                    if (stats.hunger < 1f)
                    {
                        Eat(consumed, target);
                    }
                    break;

                case SustainedConsumable.Type.Water:
                    if (stats.thirst < 1f)
                    {
                        Drink(consumed, target);
                    }
                    break;

                case SustainedConsumable.Type.Prey:
                    if (this is PredatorAgent predator && predator.stats.hunger < 1f)
                    {
                        if (target.TryGetComponent<PreyAgent>(out var prey))
                            EatAnimal(consumed, target, prey);
                        else
                        {
                            StopCurrentConsumption();
                            yield break;
                        }
                    }
                    else
                    {
                        StopCurrentConsumption();
                        yield break;
                    }
                    break;
            }

            if (target.remainingValue <= 0f && target.consumableType != SustainedConsumable.Type.Prey)
            {
                Destroy(target.gameObject);
                StopCurrentConsumption();
                yield break;
            }

            elapsed += target.tickInterval;
            yield return Timing.WaitForSeconds(target.tickInterval);
        }

        StopCurrentConsumption();
    }

    public void CheckForMating(Collider other)
    {
        if (!stats.CanMate || IsMating) return;

        if (other.TryGetComponent<AgentAnimalBase>(out var partner) &&
            partner != this &&
            partner.stats.CanMate &&
            !partner.IsMating &&
            partner.GetType() == GetType())
        {
            matingCoroutine = Timing.RunCoroutine(HandleMating(partner));
        }
    }

    private IEnumerator<float> HandleMating(AgentAnimalBase partner)
    {
        float matingTime = 0f;
        const float tick = 0.2f;
        while (matingTime < 2f)          // 2 s total
        {
            yield return Timing.WaitForSeconds(tick);
            RewardUtility.AddMatingReward(this);
            matingTime += tick;
        }

        stats.Mate();
        partner.stats.Mate();
        animalBar.UpdateFromStats();
        partner.animalBar.UpdateFromStats();

        // Create inherited child
        AgentStats childStats = GeneticUtility.Inherit(stats, partner.stats);
        Vector3 spawnPos = (transform.position + partner.transform.position) / 2f;
        EcosystemManager.Instance.SpawnAnimal(this, childStats, spawnPos);

        RewardUtility.AddMatingSuccessReward(this);
    }

    public override void Die()
    {
        RewardUtility.AddDeathPenalty(this);
        base.Die();

        StopCurrentConsumption();
        if (matingCoroutine.IsRunning)
            Timing.KillCoroutines(matingCoroutine);
    }

    protected void Eat(float amt, SustainedConsumable target)
    {
        stats.Eat(amt);
        RewardUtility.AddNutritionReward(this, amt);
        target.Consume(amt);
        animalBar.UpdateFromStats();
    }

    protected void EatAnimal(float amt, SustainedConsumable target, PreyAgent prey)
    {
        prey.stats.TakeDamage(amt);
        stats.Eat(amt);
        RewardUtility.AddPredationReward(this, amt);
        target.Consume(amt);
        animalBar.UpdateFromStats();
    }

    protected void Drink(float amt, SustainedConsumable target)
    {
        stats.Drink(amt);
        RewardUtility.AddWaterReward(this, amt);
        target.Consume(amt);
        animalBar.UpdateFromStats();
    }

    public override void UpdateSize()
    {
        if (!Mathf.Approximately(transform.localScale.y, stats.CurrentSize))
            transform.localScale = Vector3.one * stats.CurrentSize;
    }
}


--- FILE: Agents\AgentBase.cs ---
using Unity.MLAgents;
using Unity.MLAgents.Sensors;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class AgentBase : Agent
{
    protected Rigidbody rb;
    protected Vector2 currentMove;
    protected float brake;
    public AgentStats stats;
    public float maxSpeed;

    [SerializeField] protected AnimalBar animalBar;

    protected override void OnEnable()
    {
        base.OnEnable();
        EcosystemManager.Instance.Register(this);
    }

    private void OnDestroy()
    {
        if (!Application.isPlaying || EcosystemManager.Instance == null)
            return;

        EcosystemManager.Instance.Unregister(this);
    }

    protected virtual void Awake()
    {
        rb = GetComponent<Rigidbody>();
        animalBar = GetComponentInChildren<AnimalBar>();
    }

    protected virtual void Start()
    {
        if (TryGetComponent<Unity.MLAgents.Policies.BehaviorParameters>(out var bp))
        {
            bp.BehaviorType = EcosystemManager.Instance.UseHeuristicControl
                ? Unity.MLAgents.Policies.BehaviorType.HeuristicOnly
                : Unity.MLAgents.Policies.BehaviorType.Default;
        }
    }

    public virtual void InitializeStats(AgentStats inherited = null)
    {
        stats = inherited ?? new AgentStats(
                     Random.Range(10f, 20f),  // speed
                     Random.Range(1.5f, 2.5f),  // maxSize
                     Random.Range(0.8f, 1.5f)); // sightRange (keep in small bounds)

        maxSpeed = stats.speed;
        transform.localScale = Vector3.one * stats.CurrentSize;
        animalBar.SetStats(stats);

        // scale RayPerception length by sightRange
        const float baseRay = 20f; // baseline
        foreach (var sensor in GetComponents<RayPerceptionSensorComponent3D>())
            sensor.RayLength = baseRay * stats.sightRange;
    }

    public virtual void FixedUpdate()
    {
        stats.TickDecay(Time.fixedDeltaTime);

        if (!stats.IsAlive)
        {
            Die();
            return;
        }

        RewardUtility.AddDecayPenalty(this, stats.hunger, stats.thirst);

        // Interpret currentMove.y as forward/backward
        Vector3 moveDir = transform.forward * currentMove.y;
        Vector3 desiredXZ = (1f - brake) * maxSpeed * moveDir.normalized;
        Vector3 prevVel = rb.velocity;

        rb.velocity = new Vector3(desiredXZ.x, rb.velocity.y, desiredXZ.z);

        CustomLogger.Log($"MoveDir: {moveDir}, Brake: {brake}, MaxSpeed: {maxSpeed}, Velocity: {rb.velocity}, PreviousVelocity: {prevVel}");
        // Rotate based on currentMove.x (A/D keys)
        if (Mathf.Abs(currentMove.x) > 0.01f)
        {
            float turnSpeed = 120f; // degrees per second
            transform.Rotate(Vector3.up, currentMove.x * turnSpeed * Time.fixedDeltaTime);
        }

        UpdateSize();
    }

    public virtual void UpdateSize() { }
    public virtual void Die()
    {
        Telemetry.Instance.OnAgentDeath();
        Telemetry.Instance.AddReward(GetCumulativeReward());
    }
}


--- FILE: Agents\AgentStats.cs ---
using UnityEngine;

[System.Serializable]
public class AgentStats
{
    public float hunger = 1f;
    public float thirst = 1f;
    public float health = 1f;

    public float speed = 1f;
    public float sightRange = 1f;
    public float maxSize = 1f;

    public float hungerDecayRate = 0.02f;
    public float thirstDecayRate = 0.03f;
    public float healthDecayRate = 0.01f;
    public float healthRegenRate = 0.02f;

    public float MaxLifetime = 60f;
    public float growthTime = 20f;
    public float age = 0f;

    public float hungerPauseUntil = 0f;
    public float thirstPauseUntil = 0f;

    public float CurrentSize => growthTime <= 0f
        ? maxSize
        : Mathf.Lerp(1f, maxSize, Mathf.Clamp01(age / growthTime));

    public bool IsAdult => age >= growthTime;
    public bool IsAlive => hunger > 0f && thirst > 0f && health > 0f && age < MaxLifetime;

    public AgentStats() { }

    public AgentStats(float speed, float maxSize, float sightRange)
    {
        this.speed = speed;
        this.maxSize = maxSize;
        this.sightRange = sightRange;
    }

    public void TickDecay(float dt)
    {
        age += dt;

        if (Time.time >= hungerPauseUntil)

            DecreaseHunger(hungerDecayRate * dt);
        if (Time.time >= thirstPauseUntil)
            DecreaseThirst(thirstDecayRate * dt);

        // Health logic
        if (hunger < 0.3f || thirst < 0.3f)
            TakeDamage(healthDecayRate * dt);
        else if (hunger >= 0.5f && thirst >= 0.5f)
            IncreaseHealth(healthRegenRate * dt);
        // else do nothing (health stays same)
    }


    public void Eat(float amount)
    {
        hunger = Mathf.Clamp01(hunger + amount);
        hungerPauseUntil = Time.time + 2f;
    }

    public void Drink(float amount)
    {
        thirst = Mathf.Clamp01(thirst + amount);
        thirstPauseUntil = Time.time + 2f;
    }

    public void TakeDamage(float amount)
    {
        health = Mathf.Clamp01(health - amount);
    }

    public void IncreaseHealth(float amount)
    {
        health += amount;
                health = Mathf.Clamp01(health);
    }

    public void Mate()
    {
        DecreaseHunger(0.2f);
        DecreaseThirst(0.2f);
    }

    public void DecreaseHunger(float value)
    {
        hunger -= value;
        hunger = Mathf.Clamp01(hunger);
    }

    public void DecreaseThirst(float value)
    {
        thirst -= value;
        thirst = Mathf.Clamp01(thirst);
    }

    public bool CanMate => IsAdult && hunger >= 0.7f && thirst >= 0.7f;

    public static AgentStats Clone(AgentStats source)
    {
        return new AgentStats
        {
            hunger = source.hunger,
            thirst = source.thirst,
            health = source.health,
            speed = source.speed,
            sightRange = source.sightRange,
            maxSize = source.maxSize,
            hungerDecayRate = source.hungerDecayRate,
            thirstDecayRate = source.thirstDecayRate,
            healthDecayRate = source.healthDecayRate,
            healthRegenRate = source.healthRegenRate,
            MaxLifetime = source.MaxLifetime,
            growthTime = source.growthTime,
            age = 0f, // newborn
            hungerPauseUntil = 0f,
            thirstPauseUntil = 0f
        };
    }
}


--- FILE: Agents\PredatorAgent.cs ---
using Unity.MLAgents.Actuators;
using UnityEngine;

public class PredatorAgent : AgentAnimalBase
{
    public override void OnEpisodeBegin()
    {
        InitializeStats();
        transform.position = EcosystemManager.Instance.GetSpawnPosition();
        rb.velocity = Vector3.zero;
    }

    public override void CollectObservations(Unity.MLAgents.Sensors.VectorSensor sensor)
    {
        sensor.AddObservation(stats.hunger);
        sensor.AddObservation(stats.thirst);
        sensor.AddObservation(stats.CanMate ? 1f : 0f);
        sensor.AddObservation(stats.CurrentSize / 3f);
        sensor.AddObservation(stats.maxSize / 3f);
        sensor.AddObservation(stats.speed / 5f);
    }

    public override void OnActionReceived(ActionBuffers actions)
    {
        currentMove = new Vector2(actions.ContinuousActions[0], actions.ContinuousActions[1]);
        brake = Mathf.Clamp01(actions.DiscreteActions[0]);
    }

    public override void Heuristic(in ActionBuffers actionsOut)
    {
        var continuous = actionsOut.ContinuousActions;
        var discrete = actionsOut.DiscreteActions;

        continuous[0] = Input.GetAxis("Horizontal");
        continuous[1] = Input.GetAxis("Vertical");

        discrete[0] = Input.GetKey(KeyCode.Space) ? 1 : 0;
        CustomLogger.Log($"Heuristic called : {continuous[0]},{continuous[1]},{discrete[0]}");
    }

    public override void Die()
    {
        base.Die();
        EcosystemManager.Instance.Remove(gameObject);
        EndEpisode();
    }
}


--- FILE: Agents\PreyAgent.cs ---
using Unity.MLAgents.Actuators;
using UnityEngine;

[RequireComponent(typeof(SustainedConsumable))]
public class PreyAgent : AgentAnimalBase
{
    private SustainedConsumable sustainedConsumable;
    protected override void Awake()
    {
        base.Awake();
        sustainedConsumable = GetComponent<SustainedConsumable>();
    }

    public override void OnEpisodeBegin()
    {
        InitializeStats();
        rb.velocity = Vector3.zero;
    }

    public override void CollectObservations(Unity.MLAgents.Sensors.VectorSensor sensor)
    {
        sensor.AddObservation(stats.hunger);
        sensor.AddObservation(stats.thirst);
        sensor.AddObservation(stats.CanMate ? 1f : 0f);
        sensor.AddObservation(stats.CurrentSize / 3f);
        sensor.AddObservation(stats.maxSize / 3f);
        sensor.AddObservation(stats.speed / 5f);
    }

    public override void OnActionReceived(ActionBuffers actions)
    {
        currentMove = new Vector2(actions.ContinuousActions[0], actions.ContinuousActions[1]);
        brake = Mathf.Clamp01(actions.DiscreteActions[0]);
    }

    public override void Heuristic(in ActionBuffers actionsOut)
    {
        var continuous = actionsOut.ContinuousActions;
        var discrete = actionsOut.DiscreteActions;

        continuous[0] = Input.GetAxis("Horizontal");
        continuous[1] = Input.GetAxis("Vertical");

        discrete[0] = Input.GetKey(KeyCode.Space) ? 1 : 0;

        CustomLogger.Log($"Heuristic called : {continuous[0]},{continuous[1]},{discrete[0]}");
    }

    public override void UpdateSize()
    {
        if (transform.localScale.y != stats.CurrentSize)
        {
            transform.localScale = Vector3.one * stats.CurrentSize;
            sustainedConsumable.UpdateFromSize(stats.CurrentSize);
        }
    }

    public override void Die()
    {
        base.Die();
        EcosystemManager.Instance.Remove(gameObject);
        EndEpisode();
    }
}


--- FILE: Environment\AnimalBar.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AnimalBar : MonoBehaviour
{
    [Header("Stats Source")]
    public AgentStats stats;

    [Header("UI References")]
    [SerializeField] private Image hungerBar;
    [SerializeField] private Image thirstBar;
    [SerializeField] private Image healthBar;
    [SerializeField] private Image matingIcon;

    [Header("Smoothing")]
    [Range(1f, 20f)] public float lerpSpeed = 10f;

    public void SetStats(AgentStats newStats) => stats = newStats;

    private void Update()
    {
        if (stats == null) return;

        if (hungerBar && hungerBar.fillAmount != stats.hunger) hungerBar.fillAmount = Mathf.Lerp(hungerBar.fillAmount, stats.hunger, Time.deltaTime * lerpSpeed);
        if (thirstBar && thirstBar.fillAmount != stats.thirst) thirstBar.fillAmount = Mathf.Lerp(thirstBar.fillAmount, stats.thirst, Time.deltaTime * lerpSpeed);
        if (healthBar && healthBar.fillAmount != stats.health) healthBar.fillAmount = Mathf.Lerp(healthBar.fillAmount, stats.health, Time.deltaTime * lerpSpeed);

        Color mateColor = stats.CanMate ? Color.red : Color.white;
        if (matingIcon && matingIcon.color != mateColor) matingIcon.color = mateColor;
    }

    public void UpdateFromStats()
    {
        return;
    }
}


--- FILE: Environment\EcosystemManager.cs ---
using System.Collections.Generic;
using UnityEngine;

public class EcosystemManager : Singleton<EcosystemManager>
{
    public GameObject Environment;
    public Vector2 bounds = new(20, 20);
    public bool UseHeuristicControl = true;  // Toggle globally in Inspector or via UI

    /* ─── Active-agent tracking ─── */
    private readonly HashSet<AgentBase> liveAgents = new();
    private bool isResettingEnvironment = false;

    public void Register(AgentBase agent)
    {
        liveAgents.Add(agent);
    }
    public void Unregister(AgentBase agent)
    {
        liveAgents.Remove(agent);

        // if everyone died, restart environment & episode
        if (liveAgents.Count == 0 && !isResettingEnvironment)
        {
            ResetEnvironment();
        }
    }
    
    private void FixedUpdate()
    {
        // 1) record current population size
        Stats.RecordSurvival(liveAgents.Count);

        float ageSum = 0f;
        foreach (var agent in liveAgents)
            ageSum += agent.stats.age;

        Stats.RecordMeanAge(ageSum / liveAgents.Count);
    }

    public Vector3 GetSpawnPosition(int quadrant = 0)
    {
        Vector3 center = Environment.transform.position;   // origin of the whole map

        float halfX = bounds.x;    // positive half-extent in X
        float halfZ = bounds.y;    // positive half-extent in Z
        CustomLogger.Log(quadrant);

        float x = quadrant switch
        {
            1 => Random.Range(0f, halfX),   // +x
            2 => Random.Range(-halfX, 0f),    // –x
            3 => Random.Range(-halfX, 0f),    // –x
            4 => Random.Range(0f, halfX),   // +x
            _ => Random.Range(-halfX, halfX)  // any
        };

        float z = quadrant switch
        {
            1 => Random.Range(0f, halfZ),   // +z
            2 => Random.Range(0f, halfZ),   // +z
            3 => Random.Range(-halfZ, 0f),    // –z
            4 => Random.Range(-halfZ, 0f),    // –z
            _ => Random.Range(-halfZ, halfZ)  // any
        };

        return center + new Vector3(x, 1f, z);
    }

    public void SpawnAnimal(AgentAnimalBase parent, AgentStats childStats, Vector3 spawnPos)
    {
        GameObject animalPrefab = parent is PreyAgent ? SpawnerManager.Instance.preyPrefabs[0] : SpawnerManager.Instance.predatorPrefabs[0];

        GameObject child = Instantiate(animalPrefab, spawnPos, Quaternion.identity);
        if (child.TryGetComponent(out AgentBase agentBase))
        {
            agentBase.InitializeStats(AgentStats.Clone(childStats));   // newborn stats
        }
        Telemetry.Instance.OnAgentSpawn();
    }

    /* ─── world reset ─── */
    public void ResetEnvironment()
    {
        if (isResettingEnvironment || SpawnerManager.Instance == null || Telemetry.Instance == null)
            return;

        isResettingEnvironment = true;

        Telemetry.Instance.OnEpisodeEnd();

        foreach (var animal in FindObjectsByType<AgentAnimalBase>(FindObjectsInactive.Include, FindObjectsSortMode.InstanceID))
            Destroy(animal.gameObject);

        foreach (var consumable in FindObjectsByType<SustainedConsumable>(FindObjectsInactive.Include, FindObjectsSortMode.InstanceID))
            Destroy(consumable.gameObject);

        SpawnerManager.Instance.Reinitialise();
        liveAgents.Clear();

        Telemetry.Instance.OnEpisodeBegin();
        isResettingEnvironment = false;
    }

    /* convenience remove wrapper */
    public void Remove(GameObject agent) => Destroy(agent);

#if UNITY_EDITOR
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.cyan;
        Vector3 center = transform.position;
        Vector3 size = new(bounds.x * 2, 1f, bounds.y * 2); // y=1 for a flat cube
        Gizmos.DrawWireCube(center, size);

        // Draw quadrant lines
        Vector3 xStart = center + new Vector3(-bounds.x, 0, 0);
        Vector3 xEnd = center + new Vector3(bounds.x, 0, 0);
        Vector3 zStart = center + new Vector3(0, 0, -bounds.y);
        Vector3 zEnd = center + new Vector3(0, 0, bounds.y);
        Gizmos.DrawLine(xStart, xEnd);
        Gizmos.DrawLine(zStart, zEnd);

        // Define quadrant centers
        Vector3 q1 = center + new Vector3(bounds.x / 2, 0, bounds.y / 2);
        Vector3 q2 = center + new Vector3(-bounds.x / 2, 0, bounds.y / 2);
        Vector3 q3 = center + new Vector3(-bounds.x / 2, 0, -bounds.y / 2);
        Vector3 q4 = center + new Vector3(bounds.x / 2, 0, -bounds.y / 2);

        // Draw labels
        UnityEditor.Handles.color = Color.white;
        var labelStyle = new GUIStyle(GUI.skin.label)
        {
            alignment = TextAnchor.MiddleCenter,
            normal = { textColor = Color.white }
        };

        // Draw quadrant labels
        UnityEditor.Handles.Label(q1 + Vector3.up * 2f, "Quadrant 1\nPrey", labelStyle);
        UnityEditor.Handles.Label(q2 + Vector3.up * 2f, "Quadrant 2", labelStyle);
        UnityEditor.Handles.Label(q3 + Vector3.up * 2f, "Quadrant 3\nPredator", labelStyle);
        UnityEditor.Handles.Label(q4 + Vector3.up * 2f, "Quadrant 4", labelStyle);
    }
#endif
}


--- FILE: Environment\ResourceBar.cs ---
using UnityEngine;
using UnityEngine.UI;

public class ResourceBar : MonoBehaviour
{
    public SustainedConsumable consumable;
    [SerializeField] private Image resourceBar;
    [Range(1f, 20f)] public float lerpSpeed = 10f;

    public void SetConsumable(SustainedConsumable consumable) => this.consumable = consumable;

    private void Update()
    {
        if (resourceBar && resourceBar.fillAmount != consumable.remainingValue)
            resourceBar.fillAmount = Mathf.Lerp(resourceBar.fillAmount, consumable.remainingValue, Time.deltaTime * lerpSpeed);
        // resourceBar.fillAmount = Mathf.Lerp(resourceBar.fillAmount, value, Time.deltaTime * lerpSpeed);
    }
}


--- FILE: Environment\SpawnerManager.cs ---
using System.Collections.Generic;
using MEC;
using UnityEngine;

public class SpawnerManager : Singleton<SpawnerManager>
{
    public enum SpawnType { Food, Water, Prey, Predator }

    [Header("Prefabs")]
    public List<GameObject> preyPrefabs;
    public List<GameObject> predatorPrefabs;
    public List<GameObject> foodPrefabs;
    public GameObject waterPrefab;

    [Header("Spawn Settings")]
    public int initialPrey = 10;
    public int initialPredators = 5;
    public int initialFood = 20;
    public int initialWater = 10;

    public bool spawnPrey = true;
    public bool spawnPredators = false;

    [Header("Respawn Settings")]
    public bool SpawnInIntervals = true;
    public float foodSpawnInterval = 10f;
    public int foodSpawnAmount = 5;
    public float waterSpawnInterval = 20f;
    public int waterSpawnAmount = 2;

    [Header("Collision Avoidance")]
    public float checkRadius = 1.15f;
    public int maxSpawnAttempts = 10;
    public LayerMask obstacleMask;
    public TagMask blockingTags;

    GameObject PreyParent;
    GameObject PredatorParent;
    GameObject FoodParent;
    GameObject WaterParent;

    CoroutineHandle foodSpawnHandle;
    CoroutineHandle waterSpawnHandle;

    void Start()
    {
        PreyParent = new GameObject($"Spawned-Prey");
        PredatorParent = new GameObject($"Spawned-Predator");
        FoodParent = new GameObject($"Spawned-Food");
        WaterParent = new GameObject($"Spawned-Water");

        if (spawnPrey)
            Spawn(preyPrefabs, initialPrey, SpawnType.Prey);
        if (spawnPredators)
            Spawn(predatorPrefabs, initialPredators, SpawnType.Predator);

        Spawn(foodPrefabs, initialFood, SpawnType.Food);
        Spawn(waterPrefab, initialWater, SpawnType.Water);

        if (SpawnInIntervals)
        {
            foodSpawnHandle = Timing.RunCoroutine(SpawnFoodRoutine());
            waterSpawnHandle = Timing.RunCoroutine(SpawnWaterRoutine());
        }

        if (Telemetry.Instance && Telemetry.Instance.EpisodeIndex == 0)
                Telemetry.Instance.OnEpisodeBegin();              // ✱ first launch
    }

    [ContextMenu("Spawn Prey")]
    public void SpawnPrey() => Spawn(preyPrefabs, initialPrey, SpawnType.Prey);

    void Spawn(List<GameObject> prefabs, int count, SpawnType type)
    {
        if (prefabs.Count == 0 || count <= 0) return;

        Transform parent = GetParent(type);
        int quadrant = type switch
        {
            SpawnType.Prey => 1,
            SpawnType.Predator => 3,
            _ => 0    // food / water anywhere
        };

        for (int i = 0; i < count; i++)
        {
            int idx = Random.Range(0, prefabs.Count);
            Vector3 pos = GetValidSpawnPosition(prefabs[idx], quadrant);
            if (pos == Vector3.positiveInfinity) continue;

            Quaternion rot = Quaternion.Euler(0, Random.Range(0f, 360f), 0);
            Instantiate(prefabs[idx], pos, rot, parent);
        }
    }

    void Spawn(GameObject prefab, int count, SpawnType type)
    {
        if (prefab == null || count <= 0) return;

        Transform parent = GetParent(type);
        int quadrant = (type == SpawnType.Predator) ? 3 :
                       (type == SpawnType.Prey) ? 1 : 0;

        for (int i = 0; i < count; i++)
        {
            Vector3 pos = GetValidSpawnPosition(prefab, quadrant);
            if (pos == Vector3.positiveInfinity) continue;
            Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
            Instantiate(prefab, pos, rot, parent);
        }
    }

    private IEnumerator<float> SpawnFoodRoutine()
    {
        while (true)
        {
            yield return Timing.WaitForSeconds(foodSpawnInterval);
            Spawn(foodPrefabs, foodSpawnAmount, SpawnType.Food);
        }
    }

    private IEnumerator<float> SpawnWaterRoutine()
    {
        while (true)
        {
            yield return Timing.WaitForSeconds(waterSpawnInterval);
            Spawn(waterPrefab, waterSpawnAmount, SpawnType.Water);
        }
    }

    public void Reinitialise()
    {
        Destroy(PreyParent);
        Destroy(PredatorParent);
        Destroy(FoodParent);
        Destroy(WaterParent);
        Timing.KillCoroutines(foodSpawnHandle);
        Timing.KillCoroutines(waterSpawnHandle);
        Start();               // fresh start
    }

    Transform GetParent(SpawnType type)
    {
        return type switch
        {
            SpawnType.Food => FoodParent.transform,
            SpawnType.Water => WaterParent.transform,
            SpawnType.Prey => PreyParent.transform,
            SpawnType.Predator => PredatorParent.transform,
            _ => new GameObject("ErrorSpawn").transform,
        };
    }

    static readonly Collider[] probeHits = new Collider[16];   // tweak size as needed
    Vector3 GetValidSpawnPosition(GameObject prefab, int quadrant = 0)
    {
        float radius = checkRadius * Mathf.Max(prefab.transform.localScale.x,
                                               prefab.transform.localScale.y,
                                               prefab.transform.localScale.z);

        for (int attempt = 0; attempt < maxSpawnAttempts; attempt++)
        {
            Vector3 pos = EcosystemManager.Instance.GetSpawnPosition(quadrant);
            pos.y = prefab.transform.localScale.y;

            int hitCount = Physics.OverlapSphereNonAlloc(
                pos, radius, probeHits, obstacleMask, QueryTriggerInteraction.Collide);

            bool blocked = false;
            for (int i = 0; i < hitCount; i++)
            {
                Collider c = probeHits[i];
                if (!c || string.IsNullOrEmpty(c.tag)) continue;
                if (blockingTags.Contains(c.tag)) { blocked = true; break; }
            }

            if (!blocked) return pos;
        }

        CustomLogger.LogWarning($"[SpawnerManager] Could not place {prefab.name} in quadrant {quadrant}");
        return Vector3.positiveInfinity;
    }
}


--- FILE: Environment\SustainedConsumable.cs ---
using UnityEngine;

[DisallowMultipleComponent]
public class SustainedConsumable : MonoBehaviour
{
    public enum Type { Food, Water, Prey }

    [Header("Consumption Type")]
    public Type consumableType;
    [SerializeField] private ResourceBar resourceBar;

    [Header("Value Settings")]
    public float totalValue = 3f;
    public float remainingValue;
    public float tickInterval = 0.2f;

    [Header("Timing")]
    public float duration = 1f;

    [HideInInspector] public float valuePerTick;
    [HideInInspector] public int totalTicks;

    private void Awake()
    {
        InitializeValues();
        resourceBar = GetComponentInChildren<ResourceBar>();
        resourceBar.SetConsumable(this);
    }

    public void InitializeValues()
    {
        remainingValue = totalValue;
        if (tickInterval <= 0.01f) tickInterval = 0.2f;
        if (duration <= 0f) duration = 1f;

        totalTicks = Mathf.Max(1, Mathf.RoundToInt(duration / tickInterval));
        valuePerTick = totalValue / totalTicks;

        if (consumableType == Type.Prey)
        {
            duration = 2f;
            if (TryGetComponent<PreyAgent>(out var sc))
            {
                float biomass = sc.stats.CurrentSize;
                totalValue = Mathf.Clamp(biomass, 1f, 5f);
                duration = biomass * 2f;
            }
        }
    }

    /// <summary>
    /// Only for Prey, updating value based on size as animal grows
    /// </summary>
    public void UpdateFromSize(float newBiomass)
    {
        if (consumableType != Type.Prey) return;

        float clampedBiomass = Mathf.Clamp(newBiomass, 1f, 5f);
        float previousTotal = totalValue;
        float consumedFraction = 1f - (remainingValue / previousTotal);

        totalValue = clampedBiomass;
        duration = clampedBiomass * 2f;

        totalTicks = Mathf.Max(1, Mathf.RoundToInt(duration / tickInterval));
        valuePerTick = totalValue / totalTicks;

        remainingValue = totalValue * (1f - consumedFraction);
    }

    /// <summary>
    /// Consume a fixed amount. Returns how much was actually consumed.
    /// </summary>
    public float Consume(float amount)
    {
        float consumed = Mathf.Min(amount, remainingValue);
        if (consumed <= 0f) return 0f;

        remainingValue -= consumed;
        remainingValue = Mathf.Max(0f, remainingValue);
        return consumed;
    }
}


--- FILE: Utilities\CustomLogger.cs ---
using System;
using UnityEngine;
#if UNITY_EDITOR

public static class CustomLogger
{
    private static readonly bool isLoggingEnabled = false;
    public static void Log(object message)
    {
        if (isLoggingEnabled)
        {
            Debug.Log(message);
        }
    }

    public static void LogWarning(object message)
    {
        if (isLoggingEnabled)
        {
            Debug.LogWarning(message);
        }
    }

    public static void LogError(object message)
    {
        if (isLoggingEnabled)
        {
            Debug.LogError(message);
        }
    }

    public static void LogException(Exception exception)
    {
        if (isLoggingEnabled)
        {
            Debug.LogException(exception, null);
        }
    }
    
    public static void DrawRay(Vector3 start, Vector3 dir, Color color)
    {
        if (isLoggingEnabled)
        {
            Debug.DrawRay(start, dir, color);
        }
    }
}
#else
// In builds, the CustomLogger class exists but all methods are effectively no-ops.
// This prevents any potential compiler or runtime errors due to missing methods.
public static class CustomLogger
{
    public static void Log(object message) { }

    public static void LogWarning(object message) { }

    public static void LogError(object message) { }

    public static void LogException(Exception exception) { }

    public static void DrawRay(Vector3 start, Vector3 dir, Color color) { }
}
#endif


--- FILE: Utilities\GeneticUtility.cs ---
using UnityEngine;

public static class GeneticUtility
{
    public static float Blend(float a, float b, float mutationRange = 0.05f)
    {
        float baseValue = Mathf.Lerp(a, b, Random.value);
        return baseValue + Random.Range(-mutationRange, mutationRange);
    }

    public static AgentStats Inherit(AgentStats p1, AgentStats p2)
    {
        float sRange = Mathf.Clamp(Blend(p1.sightRange, p2.sightRange), 0.5f, 3f);
        return new AgentStats(
            Blend(p1.speed, p2.speed),
            Blend(p1.maxSize, p2.maxSize),
            sRange);
    }
}


--- FILE: Utilities\RewardUtility.cs ---
using Unity.MLAgents;
using UnityEngine;

public static class RewardUtility
{
    /// <summary>Reward for consuming food. Baseline: +0.2 for 0.1 units.</summary>
    public static void AddNutritionReward(Agent agent, float amount)
    {
        float scaled = 0.2f * amount / 0.1f;
        agent.AddReward(scaled);
    }

    /// <summary>Reward for drinking water. Baseline: +0.2 for 0.1 units.</summary>
    public static void AddWaterReward(Agent agent, float amount)
    {
        float scaled = 0.2f * amount / 0.1f;
        agent.AddReward(scaled);
    }

    /// <summary>Reward for predator consuming prey. Baseline: +5.0 for 0.6 units.</summary>
    public static void AddPredationReward(Agent agent, float amount)
    {
        float scaled = 5.0f * amount / 0.6f;
        agent.AddReward(scaled);
    }

    /// <summary>Reward for Mating. Baseline: +0.2 for delta.</summary>
    public static void AddMatingReward(Agent agent, float amount = 0.3f)
    {
        agent.AddReward(amount);
    }
    /// <summary>Reward for Mating. Baseline: +5 for success.</summary>
    public static void AddMatingSuccessReward(Agent agent, float amount = 5f)
    {
        agent.AddReward(amount);
    }

    /// <summary>Negative reward for being hungry or thirsty each frame. Penalty scales with deficiency.</summary>
    public static void AddDecayPenalty(Agent agent, float hunger, float thirst)
    {
        float penalty = ComputePenalty(hunger) + ComputePenalty(thirst);
        penalty = Mathf.Clamp(penalty, -0.1f, 0f);        // ✱ stabilises PPO
        agent.AddReward(penalty * Time.fixedDeltaTime);
    }
    
    /// <summary>Flat death penalty. Called once on death.</summary>
    public static void AddDeathPenalty(Agent agent)
    {
        agent.AddReward(-1f);
    }

    /// <summary>Flat death penalty. Called once on death.</summary>
    public static void AddWallHitPenalty(Agent agent)
    {
        agent.AddReward(-0.5f);
    }

    /// <summary>Custom reward value for debugging or sparse events.</summary>
    public static void AddCustom(Agent agent, float value)
    {
        agent.AddReward(value);
    }

    private static float ComputePenalty(float value)
    {
        if (value >= 0.7f) return 0f;
        if (value >= 0.3f) return -0.0025f * ((0.7f - value) / 0.1f);
        return -0.01f * ((0.3f - value) / 0.1f);
    }
}


--- FILE: Utilities\Stats.cs ---
using Unity.MLAgents;

public static class Stats
{
    static readonly StatsRecorder SR = Academy.Instance.StatsRecorder;

    public static void RecordSurvival(int alive)
        => SR.Add("Environment/Alive", alive, StatAggregationMethod.MostRecent);

    public static void RecordMeanAge(float meanAge)
        => SR.Add("Population/MeanAge", meanAge, StatAggregationMethod.MostRecent);

    public static void RecordEpisodeReturn(float ret)
        => SR.Add("Episode/Return", ret, StatAggregationMethod.MostRecent);
}


--- FILE: Utilities\TagMask.cs ---
#if UNITY_EDITOR
using UnityEditor;
using UnityEditorInternal;
#endif
using UnityEngine;

[System.Serializable]
public class TagMask
{
    [SerializeField, HideInInspector] private int mask;

    /// <summary>Returns true if the given tag is selected in the mask.</summary>
    public bool Contains(string tag)
    {
        int index = GetTagIndex(tag);
        return index >= 0 && (mask & (1 << index)) != 0;
    }

    /// <summary>Build a tag mask from selected tag names.</summary>
    public void SetSelectedTags(string[] selectedTags)
    {
        mask = 0;
        foreach (var tag in selectedTags)
        {
            int index = GetTagIndex(tag);
            if (index >= 0)
                mask |= 1 << index;
        }
    }

    /// <summary>Returns all selected tag names.</summary>
    public string[] GetSelectedTags()
    {
        var allTags = UnityEditorInternal.InternalEditorUtility.tags;
        var result = new System.Collections.Generic.List<string>();
        for (int i = 0; i < allTags.Length; i++)
        {
            if ((mask & (1 << i)) != 0)
                result.Add(allTags[i]);
        }
        return result.ToArray();
    }

    private int GetTagIndex(string tag)
    {
        var allTags = UnityEditorInternal.InternalEditorUtility.tags;
        for (int i = 0; i < allTags.Length; i++)
        {
            if (allTags[i] == tag) return i;
        }
        return -1;
    }

    public int RawMask => mask;
    public void SetRawMask(int raw) => mask = raw;
}


#if UNITY_EDITOR
[CustomPropertyDrawer(typeof(TagMask))]
public class TagMaskDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        var rawMaskProp = property.FindPropertyRelative("mask");

        string[] tags = InternalEditorUtility.tags;
        int currentMask = rawMaskProp.intValue;

        int newMask = EditorGUI.MaskField(position, label, currentMask, tags);
        if (newMask != currentMask)
            rawMaskProp.intValue = newMask;
    }
}
#endif

--- FILE: Utilities\Telemetry.cs ---
// Utilities/Telemetry.cs
using System.IO;
using Unity.MLAgents;
using UnityEngine;

public class Telemetry : Singleton<Telemetry>
{
    string csvPath;
    StreamWriter writer;

    protected override void Awake()
    {
        base.Awake();
        csvPath = Path.Combine(Application.persistentDataPath,
                               $"ecosim_{System.DateTime.Now:yyyyMMdd_HHmmss}.csv");
        writer = new StreamWriter(csvPath);
        writer.WriteLine("episode,startTime,endTime,aliveTime,spawned,dead,rewardSum");
    }

    /* ---------- environment level ---------- */
    public int EpisodeIndex { get; private set; } = 0;
    double episodeStart = 0.0;
    int spawned = 0;
    int dead = 0;
    float rewardSum = 0f;

    public void OnEpisodeBegin()
    {
        EpisodeIndex++;
        episodeStart = Time.timeAsDouble;
        spawned = dead = 0;
        rewardSum = 0;
    }

    public void OnAgentSpawn() => spawned++;
    public void OnAgentDeath() => dead++;

    public void AddReward(float r) => rewardSum += r;

    public void OnEpisodeEnd()
    {
        double end = Time.timeAsDouble;
        writer.WriteLine($"{EpisodeIndex},{episodeStart:F2},{end:F2},{end - episodeStart:F2}," +
                         $"{spawned},{dead},{rewardSum:F3}");
        writer.Flush();
    }

    protected override void OnDestroy()
    {
        base.OnDestroy();
        writer?.Close();
    }
}
