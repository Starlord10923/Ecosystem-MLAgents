

--- FILE: Agents\AgentAnimalBase.cs ---
using System.Collections.Generic;
using MEC;
using UnityEngine;

public abstract class AgentAnimalBase : AgentBase
{
    public enum AnimalType { Prey, Predator }
    public AnimalType animalType;
    private CoroutineHandle currentConsumption;
    private Collider currentTarget = null;

    private CoroutineHandle matingCoroutine;
    private bool IsMating => matingCoroutine.IsRunning;

    protected virtual void OnTriggerEnter(Collider other)
    {
        // Debug.Log("Triggered : " + other.name);
        if (other.CompareTag("Wall"))
            RewardUtility.AddWallHitPenalty(this);

        CheckForConsumption(other);
        CheckForMating(other);
    }

    protected virtual void OnTriggerExit(Collider other)
    {
        if (currentTarget == other)
            StopCurrentConsumption();
    }

    public void CheckForConsumption(Collider other)
    {
        if (currentConsumption.IsRunning || !other.TryGetComponent<SustainedConsumable>(out var target))
            return;
        if (animalType==AnimalType.Prey && target.consumableType == SustainedConsumable.Type.Prey)
            return;

        currentTarget = other;
        currentConsumption = Timing.RunCoroutine(ConsumeOverTime(target, other));
    }

    private void StopCurrentConsumption()
    {
        if (currentConsumption.IsRunning)
        {
            Timing.KillCoroutines(currentConsumption);
        }
        currentTarget = null;
    }

    private IEnumerator<float> ConsumeOverTime(SustainedConsumable target, Collider source)
    {
        float elapsed = 0f;

        while (elapsed < target.duration)
        {
            if (target == null)
            {
                StopCurrentConsumption();
                yield break;
            }

            float consumed = Mathf.Min(target.valuePerTick, target.remainingValue);
            if (target.remainingValue <= 0f)
            {
                StopCurrentConsumption();
                yield break;
            }

            switch (target.consumableType)
            {
                case SustainedConsumable.Type.Food:
                    if (stats.hunger < 1f)
                    {
                        Eat(consumed, target);
                    }
                    break;

                case SustainedConsumable.Type.Water:
                    if (stats.thirst < 1f)
                    {
                        Drink(consumed, target);
                    }
                    break;

                case SustainedConsumable.Type.Prey:
                    if (this is PredatorAgent predator && predator.stats.hunger < 1f)
                    {
                        if (target.TryGetComponent<PreyAgent>(out var prey))
                            EatAnimal(consumed, target, prey);
                        else
                        {
                            StopCurrentConsumption();
                            yield break;
                        }
                    }
                    else
                    {
                        StopCurrentConsumption();
                        yield break;
                    }
                    break;
            }

            if (target.remainingValue <= 0f && target.consumableType != SustainedConsumable.Type.Prey)
            {
                Destroy(target.gameObject);
                StopCurrentConsumption();
                yield break;
            }

            elapsed += target.tickInterval;
            yield return Timing.WaitForSeconds(target.tickInterval);
        }

        StopCurrentConsumption();
    }

    public void CheckForMating(Collider other)
    {
        if (!stats.CanMate || IsMating) return;

        if (other.TryGetComponent<AgentAnimalBase>(out var partner) &&
            partner != this &&
            partner.stats.CanMate &&
            !partner.IsMating &&
            partner.GetType() == GetType())
        {
            matingCoroutine = Timing.RunCoroutine(HandleMating(partner));
        }
    }

    private IEnumerator<float> HandleMating(AgentAnimalBase partner)
    {
        float matingTime = 0f;
        const float tick = 0.2f;
        while (matingTime < 2f)          // 2 s total
        {
            yield return Timing.WaitForSeconds(tick);
            RewardUtility.AddMatingReward(this);
            matingTime += tick;
        }

        stats.Mate();
        partner.stats.Mate();
        animalBar.UpdateFromStats();
        partner.animalBar.UpdateFromStats();

        // Create inherited child
        AgentStats childStats = GeneticUtility.Inherit(stats, partner.stats);
        Vector3 spawnPos = (transform.position + partner.transform.position) / 2f;
        EcosystemManager.Instance.SpawnAnimal(this, childStats, spawnPos);

        RewardUtility.AddMatingSuccessReward(this);
    }

    static readonly Collider[] probeHits = new Collider[8];   // tweak size as needed
    public void PenalizeCrowding()
    {
        // No penalty for crowding if it can mate
        if (stats.CanMate) return;

        int hitCount = Physics.OverlapSphereNonAlloc(transform.position, 2f, probeHits);
        int nearbyPrey = 0;
        for (int i = 0; i < hitCount; i++)
        {
            var hit = probeHits[i];
            if (hit == null) continue;

            if (hit.gameObject != gameObject && hit.TryGetComponent<AgentAnimalBase>(out var animal))
            {
                if (animalType == animal.animalType)
                    nearbyPrey += 1;
            }
        }

        if (nearbyPrey >= 2) // crowded
            RewardUtility.AddCrowdedPenalty(this, nearbyPrey);
    }

    public override void Die()
    {
        RewardUtility.AddDeathPenalty(this);
        base.Die();

        StopCurrentConsumption();
        if (matingCoroutine.IsRunning)
            Timing.KillCoroutines(matingCoroutine);
    }

    protected void Eat(float amt, SustainedConsumable target)
    {
        if (target.Consume(amt) > 0)
        {
            stats.Eat(amt);
            RewardUtility.AddNutritionReward(this, amt);
            animalBar.UpdateFromStats();
        }
    }

    protected void EatAnimal(float amt, SustainedConsumable target, PreyAgent prey)
    {
        if (target.Consume(amt) > 0)
        {
            prey.stats.TakeDamage(amt);
            stats.Eat(amt);
            RewardUtility.AddPredationReward(this, amt);
            animalBar.UpdateFromStats();
        }
    }

    protected void Drink(float amt, SustainedConsumable target)
    {
        if (target.Consume(amt) > 0)
        {
            stats.Drink(amt);
            RewardUtility.AddWaterReward(this, amt);
            animalBar.UpdateFromStats();
        }
    }

    public override void UpdateSize()
    {
        if (!Mathf.Approximately(transform.localScale.y, stats.CurrentSize))
            transform.localScale = Vector3.one * stats.CurrentSize;
    }
}


--- FILE: Agents\AgentBase.cs ---
using Unity.MLAgents;
using Unity.MLAgents.Sensors;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class AgentBase : Agent
{
    protected Rigidbody rb;
    protected Vector2 currentMove;
    protected float brake;
    public AgentStats stats;
    public float maxSpeed;

    [SerializeField] protected AnimalBar animalBar;

    protected override void OnEnable()
    {
        base.OnEnable();
        EcosystemManager.Instance.Register(this);
    }

    private void OnDestroy()
    {
        if (!Application.isPlaying || EcosystemManager.Instance == null)
            return;

        EcosystemManager.Instance.Unregister(this);
    }

    protected virtual void Awake()
    {
        rb = GetComponent<Rigidbody>();
        animalBar = GetComponentInChildren<AnimalBar>();
    }

    protected virtual void Start()
    {
        if (TryGetComponent<Unity.MLAgents.Policies.BehaviorParameters>(out var bp))
        {
            bp.BehaviorType = EcosystemManager.Instance.UseHeuristicControl
                ? Unity.MLAgents.Policies.BehaviorType.HeuristicOnly
                : Unity.MLAgents.Policies.BehaviorType.Default;
            if (!EcosystemManager.Instance.UseHeuristicControl)
            {
                if (this is PreyAgent && EcosystemManager.Instance.PreyBrain != null)
                    bp.Model = EcosystemManager.Instance.PreyBrain;
                else if (this is PredatorAgent && EcosystemManager.Instance.PredatorBrain != null)
                    bp.Model = EcosystemManager.Instance.PredatorBrain;
            }
        }
    }

    public virtual void InitializeStats(AgentStats inherited = null)
    {
        stats = inherited ?? new AgentStats(
                     Random.Range(10f, 20f),  // speed
                     Random.Range(1.5f, 2.5f),  // maxSize
                     Random.Range(0.8f, 1.5f)); // sightRange (keep in small bounds)

        maxSpeed = stats.speed;
        transform.localScale = Vector3.one * stats.CurrentSize;
        animalBar.SetStats(stats);

        // scale RayPerception length by sightRange
        const float baseRay = 20f; // baseline
        foreach (var sensor in GetComponents<RayPerceptionSensorComponent3D>())
            sensor.RayLength = baseRay * stats.sightRange;
    }

    private Vector3 moveDir = Vector3.zero;
    private Vector3 desiredXZ = Vector3.zero;
    public void FixedUpdate()
    {
        stats.TickDecay(Time.fixedDeltaTime);

        if (!stats.IsAlive)
        {
            if (stats.LivedFullLife)
                EcosystemManager.Instance.CumulativeData.reachedLifeEnd += 1;
            if(stats.hunger<=0f)
                EcosystemManager.Instance.CumulativeData.diedFromHunger += 1;
            if(stats.thirst<=0f)
                EcosystemManager.Instance.CumulativeData.diedFromThirst += 1;
            Die();
            return;
        }

        RewardUtility.ApplyVitalityReward(this, stats.hunger, stats.thirst);

        // Compute movement
        moveDir.Set(transform.forward.x * currentMove.y, 0f, transform.forward.z * currentMove.y);
        float speedFactor = (1f - brake) * maxSpeed;

        desiredXZ.Set(moveDir.x * speedFactor, rb.velocity.y, moveDir.z * speedFactor);
        rb.velocity = desiredXZ;

        // CustomLogger.Log($"MoveDir: {moveDir}, Brake: {brake:F2}, MaxSpeed: {maxSpeed:F2}, Velocity: {rb.velocity}, PreviousVelocity: {prevVelocity}");
        // Rotation
        if (Mathf.Abs(currentMove.x) > 0.01f)
        {
            float turnSpeed = 120f; // degrees per second
            transform.Rotate(Vector3.up, currentMove.x * turnSpeed * Time.fixedDeltaTime);
        }

        UpdateSize();
    }


    public virtual void UpdateSize() { }
    public virtual void Die()
    {
        // Debug.Log($"Animal is Dead : {gameObject.name}");
    }
}


--- FILE: Agents\AgentStats.cs ---
using UnityEngine;

[System.Serializable]
public class AgentStats
{
    public float hunger = 1f;
    public float thirst = 1f;
    public float health = 1f;

    public float speed = 1f;
    public float sightRange = 1f;
    public float maxSize = 1f;

    public float hungerDecayRate = 0.03f;
    public float thirstDecayRate = 0.02f;
    public float healthDecayRate = 0.01f;
    public float healthRegenRate = 0.02f;

    public float MaxLifetime = 60f;
    public float growthTime = 20f;
    public float age = 0f;

    public float hungerPauseUntil = 0f;
    public float thirstPauseUntil = 0f;

    public float CurrentSize => growthTime <= 0f
        ? maxSize
        : Mathf.Lerp(1f, maxSize, Mathf.Clamp01(age / growthTime));

    public bool IsAdult => age >= growthTime;
    public bool IsAlive => hunger > 0f && thirst > 0f && health > 0f && age < MaxLifetime;

    public AgentStats() { }

    public AgentStats(float speed, float maxSize, float sightRange)
    {
        this.speed = speed;
        this.maxSize = maxSize;
        this.sightRange = sightRange;
    }

    public void TickDecay(float dt)
    {
        age += dt;

        if (Time.time >= hungerPauseUntil)

            DecreaseHunger(hungerDecayRate * dt);
        if (Time.time >= thirstPauseUntil)
            DecreaseThirst(thirstDecayRate * dt);

        // Health logic
        if (hunger < 0.3f || thirst < 0.3f)
            TakeDamage(healthDecayRate * dt);
        else if (hunger >= 0.5f && thirst >= 0.5f)
            IncreaseHealth(healthRegenRate * dt);
        // else do nothing (health stays same)
    }


    public void Eat(float amount)
    {
        hunger = Mathf.Clamp01(hunger + amount);
        hungerPauseUntil = Time.time + 2f;
    }

    public void Drink(float amount)
    {
        thirst = Mathf.Clamp01(thirst + amount);
        thirstPauseUntil = Time.time + 2f;
    }

    public void TakeDamage(float amount)
    {
        health = Mathf.Clamp01(health - amount);
    }

    public void IncreaseHealth(float amount)
    {
        health += amount;
                health = Mathf.Clamp01(health);
    }

    public void Mate()
    {
        DecreaseHunger(0.2f);
        DecreaseThirst(0.2f);
    }

    public void DecreaseHunger(float value)
    {
        hunger -= value;
        hunger = Mathf.Clamp01(hunger);
    }

    public void DecreaseThirst(float value)
    {
        thirst -= value;
        thirst = Mathf.Clamp01(thirst);
    }

    public bool CanMate => IsAdult && hunger >= 0.7f && thirst >= 0.7f;
    public bool LivedFullLife => age >= MaxLifetime;

    public static AgentStats Clone(AgentStats source)
    {
        return new AgentStats
        {
            hunger = source.hunger,
            thirst = source.thirst,
            health = source.health,
            speed = source.speed,
            sightRange = source.sightRange,
            maxSize = source.maxSize,
            hungerDecayRate = source.hungerDecayRate,
            thirstDecayRate = source.thirstDecayRate,
            healthDecayRate = source.healthDecayRate,
            healthRegenRate = source.healthRegenRate,
            MaxLifetime = source.MaxLifetime,
            growthTime = source.growthTime,
            age = 0f, // newborn
            hungerPauseUntil = 0f,
            thirstPauseUntil = 0f
        };
    }
}


--- FILE: Agents\PredatorAgent.cs ---
using Unity.MLAgents.Actuators;
using UnityEngine;

public class PredatorAgent : AgentAnimalBase
{
    protected override void Awake()
    {
        base.Awake();
        animalType = AnimalType.Predator;
    }

    public override void OnEpisodeBegin()
    {
        InitializeStats();
        transform.position = EcosystemManager.Instance.GetSpawnPosition();
        rb.velocity = Vector3.zero;
    }

    public override void CollectObservations(Unity.MLAgents.Sensors.VectorSensor sensor)
    {
        sensor.AddObservation(stats.hunger);
        sensor.AddObservation(stats.thirst);
        sensor.AddObservation(stats.CanMate ? 1f : 0f);
        sensor.AddObservation(stats.CurrentSize / 3f);
        sensor.AddObservation(stats.maxSize / 3f);
        sensor.AddObservation(stats.speed / 5f);
        sensor.AddObservation(stats.MaxLifetime - stats.age);
    }

    public override void OnActionReceived(ActionBuffers actions)
    {
        currentMove = new Vector2(actions.ContinuousActions[0], actions.ContinuousActions[1]);
        brake = Mathf.Clamp01(actions.DiscreteActions[0]);
        PenalizeCrowding();
    }

    public override void Heuristic(in ActionBuffers actionsOut)
    {
        var continuous = actionsOut.ContinuousActions;
        var discrete = actionsOut.DiscreteActions;

        continuous[0] = Input.GetAxis("Horizontal");
        continuous[1] = Input.GetAxis("Vertical");

        discrete[0] = Input.GetKey(KeyCode.Space) ? 1 : 0;
        CustomLogger.Log($"Heuristic called : {continuous[0]},{continuous[1]},{discrete[0]}");
    }

    public override void Die()
    {
        base.Die();
        EcosystemManager.Instance.Remove(gameObject);
        EndEpisode();
    }
}


--- FILE: Agents\PreyAgent.cs ---
using Unity.MLAgents.Actuators;
using UnityEngine;

[RequireComponent(typeof(SustainedConsumable))]
public class PreyAgent : AgentAnimalBase
{
    private SustainedConsumable sustainedConsumable;
    protected override void Awake()
    {
        base.Awake();
        sustainedConsumable = GetComponent<SustainedConsumable>();
        animalType = AnimalType.Prey;
    }

    public override void OnEpisodeBegin()
    {
        InitializeStats();
        rb.velocity = Vector3.zero;
    }

    public override void CollectObservations(Unity.MLAgents.Sensors.VectorSensor sensor)
    {
        sensor.AddObservation(stats.hunger);
        sensor.AddObservation(stats.thirst);
        sensor.AddObservation(stats.CanMate ? 1f : 0f);
        sensor.AddObservation(stats.CurrentSize / 3f);
        sensor.AddObservation(stats.maxSize / 3f);
        sensor.AddObservation(stats.speed / 5f);
        sensor.AddObservation(stats.MaxLifetime - stats.age);
    }

    public override void OnActionReceived(ActionBuffers actions)
    {
        currentMove = new Vector2(actions.ContinuousActions[0], actions.ContinuousActions[1]);
        brake = Mathf.Clamp01(actions.DiscreteActions[0]);
        PenalizeCrowding();
    }

    public override void Heuristic(in ActionBuffers actionsOut)
    {
        var continuous = actionsOut.ContinuousActions;
        var discrete = actionsOut.DiscreteActions;

        continuous[0] = Input.GetAxis("Horizontal");
        continuous[1] = Input.GetAxis("Vertical");

        discrete[0] = Input.GetKey(KeyCode.Space) ? 1 : 0;

        CustomLogger.Log($"Heuristic called : {continuous[0]},{continuous[1]},{discrete[0]}");
    }

    public override void UpdateSize()
    {
        if (transform.localScale.y != stats.CurrentSize)
        {
            transform.localScale = Vector3.one * stats.CurrentSize;
            sustainedConsumable.UpdateFromSize(stats.CurrentSize);
        }
    }

    public override void Die()
    {
        base.Die();
        EcosystemManager.Instance.Remove(gameObject);
        EndEpisode();
    }
}


--- FILE: Environment\AnimalBar.cs ---
using UnityEngine;
using UnityEngine.UI;

public class AnimalBar : MonoBehaviour
{
    [Header("Stats Source")]
    public AgentStats stats;

    [Header("UI References")]
    [SerializeField] private Image hungerBar;
    [SerializeField] private Image thirstBar;
    [SerializeField] private Image healthBar;
    [SerializeField] private Image matingIcon;

    [Header("Smoothing")]
    [Range(1f, 20f)] public float lerpSpeed = 10f;

    public void SetStats(AgentStats newStats) => stats = newStats;

    private void Start()
    {
        if (!EcosystemManager.Instance.showValues) gameObject.SetActive(false);
    }

    private void Update()
    {
        if (stats == null) return;

        if (hungerBar && hungerBar.fillAmount != stats.hunger) hungerBar.fillAmount = Mathf.Lerp(hungerBar.fillAmount, stats.hunger, Time.deltaTime * lerpSpeed);
        if (thirstBar && thirstBar.fillAmount != stats.thirst) thirstBar.fillAmount = Mathf.Lerp(thirstBar.fillAmount, stats.thirst, Time.deltaTime * lerpSpeed);
        if (healthBar && healthBar.fillAmount != stats.health) healthBar.fillAmount = Mathf.Lerp(healthBar.fillAmount, stats.health, Time.deltaTime * lerpSpeed);

        Color mateColor = stats.CanMate ? Color.red : Color.white;
        if (matingIcon && matingIcon.color != mateColor) matingIcon.color = mateColor;
    }

    public void UpdateFromStats()
    {
        return;
    }
}


--- FILE: Environment\EcosystemManager.cs ---
using System.Collections.Generic;
using Unity.Barracuda;
using UnityEngine;

public class EcosystemManager : Singleton<EcosystemManager>
{
    public GameObject Environment;
    public Vector2 bounds = new(20, 20);
    public bool UseHeuristicControl = false;  // Toggle globally in Inspector or via UI
    public bool UseBrain = false;
    public NNModel PreyBrain;
    public NNModel PredatorBrain;
    [Range(1f, 20f)]
    public float TimeScale = 1f;

    public bool showValues = false;

    /* ─── Active-agent tracking ─── */
    private readonly HashSet<AgentBase> liveAgents = new();
    private bool isResettingEnvironment = false;

    [Header("Ecosystem Metrics")]
    public EpisodeMetrics CumulativeData = new();

    protected override void Awake()
    {
        base.Awake();
        if (!UseHeuristicControl && UseBrain)
            Time.timeScale = TimeScale;
    }

    public void Register(AgentBase agent)
    {
        liveAgents.Add(agent);
        if (agent is PreyAgent)
        {
            CumulativeData.currentPreyCount += 1;
            CumulativeData.totalPreySpawned += 1;
        }
        else
        {
            CumulativeData.currentPredatorCount += 1;
            CumulativeData.totalPredatorsSpawned += 1;
        }
    }
    public void Unregister(AgentBase agent)
    {
        liveAgents.Remove(agent);
        if (agent is PreyAgent) CumulativeData.currentPreyCount -= 1;
        else CumulativeData.currentPredatorCount -= 1;

        // if everyone died, restart environment & episode
        if (liveAgents.Count == 0 && !isResettingEnvironment)
        {
            ResetEnvironment();
        }
    }

    private static readonly List<AgentBase> agentBuffer = new(128);
    private void FixedUpdate()
    {
        int count = liveAgents.Count;
        if (count == 0)
            return;

        float ageSum = 0f;

        agentBuffer.Clear();
        agentBuffer.AddRange(liveAgents); // avoids HashSet enumeration allocation

        for (int i = 0; i < agentBuffer.Count; i++)
        {
            ageSum += agentBuffer[i].stats.age;
        }

        Stats.RecordSurvival(count);
        Stats.RecordMeanAge(ageSum / count);
    }

    public Vector3 GetSpawnPosition(int quadrant = 0)
    {
        Vector3 center = Environment.transform.position;   // origin of the whole map

        float halfX = bounds.x;    // positive half-extent in X
        float halfZ = bounds.y;    // positive half-extent in Z
        CustomLogger.Log(quadrant);

        float x = quadrant switch
        {
            1 => Random.Range(0f, halfX),   // +x
            2 => Random.Range(-halfX, 0f),    // –x
            3 => Random.Range(-halfX, 0f),    // –x
            4 => Random.Range(0f, halfX),   // +x
            _ => Random.Range(-halfX, halfX)  // any
        };

        float z = quadrant switch
        {
            1 => Random.Range(0f, halfZ),   // +z
            2 => Random.Range(0f, halfZ),   // +z
            3 => Random.Range(-halfZ, 0f),    // –z
            4 => Random.Range(-halfZ, 0f),    // –z
            _ => Random.Range(-halfZ, halfZ)  // any
        };

        return center + new Vector3(x, 1f, z);
    }

    public void SpawnAnimal(AgentAnimalBase parent, AgentStats childStats, Vector3 spawnPos)
    {
        var isPrey = parent.animalType == AgentAnimalBase.AnimalType.Prey;
        var prefabList = isPrey ? SpawnerManager.Instance.preyPrefabs : SpawnerManager.Instance.predatorPrefabs;
        var parentTransform = isPrey ? SpawnerManager.Instance.PreyParent.transform : SpawnerManager.Instance.PredatorParent.transform;

        if (prefabList.Count == 0) return;

        var child = Instantiate(prefabList[0], spawnPos, Quaternion.identity, parentTransform);
        if (child.TryGetComponent(out AgentBase agentBase))
        {
            agentBase.InitializeStats(AgentStats.Clone(childStats));   // newborn stats
        }
    }

    /* ─── world reset ─── */
    public void ResetEnvironment()
    {
        if (isResettingEnvironment || SpawnerManager.Instance == null || Telemetry.Instance == null)
            return;

        isResettingEnvironment = true;
        CumulativeData.totalEpisodes += 1;

        Telemetry.Instance.OnEpisodeEnd(CumulativeData);

        // Cache to avoid modifying collection during iteration
        var allAnimals = new List<AgentAnimalBase>(FindObjectsByType<AgentAnimalBase>(FindObjectsInactive.Include, FindObjectsSortMode.InstanceID));
        foreach (var animal in allAnimals)
            Destroy(animal.gameObject); // Triggers OnDestroy later

        var allConsumables = new List<SustainedConsumable>(FindObjectsByType<SustainedConsumable>(FindObjectsInactive.Include, FindObjectsSortMode.InstanceID));
        foreach (var consumable in allConsumables)
            Destroy(consumable.gameObject);

        liveAgents.Clear(); // explicit clear, no need to re-unregister on destroy

        SpawnerManager.Instance.Reinitialise();

        isResettingEnvironment = false;
    }

    /* convenience remove wrapper */
    public void Remove(GameObject agent) => Destroy(agent);

    private void ShowVisualValues()
    {
        foreach (var bar in FindObjectsByType<ResourceBar>(FindObjectsInactive.Include, FindObjectsSortMode.None))
            bar.gameObject.SetActive(showValues);
        foreach (var bar in FindObjectsByType<AnimalBar>(FindObjectsInactive.Include, FindObjectsSortMode.None))
            bar.gameObject.SetActive(showValues);
    }

#if UNITY_EDITOR
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.cyan;
        Vector3 center = transform.position;
        Vector3 size = new(bounds.x * 2, 1f, bounds.y * 2); // y=1 for a flat cube
        Gizmos.DrawWireCube(center, size);

        // Draw quadrant lines
        Vector3 xStart = center + new Vector3(-bounds.x, 0, 0);
        Vector3 xEnd = center + new Vector3(bounds.x, 0, 0);
        Vector3 zStart = center + new Vector3(0, 0, -bounds.y);
        Vector3 zEnd = center + new Vector3(0, 0, bounds.y);
        Gizmos.DrawLine(xStart, xEnd);
        Gizmos.DrawLine(zStart, zEnd);

        // Define quadrant centers
        Vector3 q1 = center + new Vector3(bounds.x / 2, 0, bounds.y / 2);
        Vector3 q2 = center + new Vector3(-bounds.x / 2, 0, bounds.y / 2);
        Vector3 q3 = center + new Vector3(-bounds.x / 2, 0, -bounds.y / 2);
        Vector3 q4 = center + new Vector3(bounds.x / 2, 0, -bounds.y / 2);

        // Draw labels
        UnityEditor.Handles.color = Color.white;
        var labelStyle = new GUIStyle(GUI.skin.label)
        {
            alignment = TextAnchor.MiddleCenter,
            normal = { textColor = Color.white }
        };

        // Draw quadrant labels
        UnityEditor.Handles.Label(q1 + Vector3.up * 2f, "Quadrant 1\nPrey", labelStyle);
        UnityEditor.Handles.Label(q2 + Vector3.up * 2f, "Quadrant 2", labelStyle);
        UnityEditor.Handles.Label(q3 + Vector3.up * 2f, "Quadrant 3\nPredator", labelStyle);
        UnityEditor.Handles.Label(q4 + Vector3.up * 2f, "Quadrant 4", labelStyle);
    }

    private void OnValidate()
    {
        ShowVisualValues();

        if (!UseHeuristicControl && UseBrain)
        {
            if (Time.timeScale != TimeScale)
                Time.timeScale = TimeScale;
        }
    }
#endif
}


[System.Serializable]
public class EpisodeMetrics
{
    [Header("Global Episode Tracking")]
    public int totalEpisodes = 0;

    [Header("Reward & Penalty Stats")]
    public float totalRewardGiven = 0f;
    public float totalPenaltyGiven = 0f;
    public float crowdingPenalty = 0f;

    [Header("Population Metrics")]
    public int totalPreySpawned = 0;
    public int totalPredatorsSpawned = 0;
    public int currentPreyCount = 0;
    public int currentPredatorCount = 0;

    [Header("Resource Consumption")]
    public int foodConsumed = 0;
    public int waterConsumed = 0;

    [Header("Reproduction Metrics")]
    public int totalMating = 0;
    public float partialMatingReward = 0f;

    [Header("Mortality Stats")]
    public int animalKilled = 0;
    public int reachedLifeEnd = 0;
    public int diedFromHunger = 0;
    public int diedFromThirst = 0;

    public EpisodeMetrics Clone() => (EpisodeMetrics)MemberwiseClone();
}


--- FILE: Environment\ResourceBar.cs ---
using UnityEngine;
using UnityEngine.UI;

public class ResourceBar : MonoBehaviour
{
    public SustainedConsumable consumable;
    [SerializeField] private Image resourceBar;
    [Range(1f, 20f)] public float lerpSpeed = 10f;

    public void SetConsumable(SustainedConsumable consumable) => this.consumable = consumable;

    private void Start()
    {
        if (!EcosystemManager.Instance.showValues) gameObject.SetActive(false);
    }

    private void Update()
    {
        if (resourceBar && resourceBar.fillAmount != consumable.remainingValue)
            resourceBar.fillAmount = Mathf.Lerp(resourceBar.fillAmount, consumable.remainingValue, Time.deltaTime * lerpSpeed);
        // resourceBar.fillAmount = Mathf.Lerp(resourceBar.fillAmount, value, Time.deltaTime * lerpSpeed);
    }
}


--- FILE: Environment\SpawnerManager.cs ---
using System.Collections.Generic;
using MEC;
using UnityEngine;

public class SpawnerManager : Singleton<SpawnerManager>
{
    public enum SpawnType { Food, Water, Prey, Predator }

    [Header("Prefabs")]
    public List<GameObject> preyPrefabs;
    public List<GameObject> predatorPrefabs;
    public List<GameObject> foodPrefabs;
    public GameObject waterPrefab;

    [Header("Spawn Settings")]
    public int initialPrey = 10;
    public int initialPredators = 5;
    public int initialFood = 20;
    public int initialWater = 10;

    public bool spawnPrey = true;
    public bool spawnPredators = false;

    public bool spawnInQuadrants = true;

    [Header("Respawn Settings")]
    public bool SpawnInIntervals = true;
    public float foodSpawnInterval = 10f;
    public int foodSpawnAmount = 5;
    public float waterSpawnInterval = 20f;
    public int waterSpawnAmount = 2;

    [Header("Collision Avoidance")]
    public float checkRadius = 1.15f;
    public int maxSpawnAttempts = 10;
    public LayerMask obstacleMask;
    public TagMask blockingTags;

    [Header("Holders")]
    public GameObject PreyParent;
    public GameObject PredatorParent;
    public GameObject FoodParent;
    public GameObject WaterParent;

    CoroutineHandle foodSpawnHandle;
    CoroutineHandle waterSpawnHandle;

    public int activeFood = 0;
    public int activeWater = 0;
    public void OnFoodSpawned() => activeFood++;
    public void OnWaterSpawned() => activeWater++;
    public void OnFoodConsumed() => activeFood--;
    public void OnWaterConsumed() => activeWater--;
    [Header("Dynamic Spawn Balancing")]
    public float targetFoodPerPrey = 1.5f;
    public float targetWaterPerPrey = 0.8f;

    void Start()
    {
        PreyParent = new GameObject($"Spawned-Prey");
        PredatorParent = new GameObject($"Spawned-Predator");
        FoodParent = new GameObject($"Spawned-Food");
        WaterParent = new GameObject($"Spawned-Water");

        activeFood = 0;
        activeWater = 0;

        if (spawnPrey)
            Spawn(preyPrefabs, initialPrey, SpawnType.Prey);
        if (spawnPredators)
            Spawn(predatorPrefabs, initialPredators, SpawnType.Predator);

        Spawn(foodPrefabs, initialFood, SpawnType.Food);
        Spawn(waterPrefab, initialWater, SpawnType.Water);

        if (SpawnInIntervals)
        {
            foodSpawnHandle = Timing.RunCoroutine(SpawnFoodRoutine());
            waterSpawnHandle = Timing.RunCoroutine(SpawnWaterRoutine());
        }

        Telemetry.Instance.OnEpisodeStart();
    }

    [ContextMenu("Spawn Prey")]
    public void SpawnPrey() => Spawn(preyPrefabs, initialPrey, SpawnType.Prey);

    void Spawn(List<GameObject> prefabs, int count, SpawnType type)
    {
        if (prefabs.Count == 0 || count <= 0) return;

        Transform parent = GetParent(type);
        int quadrant = type switch
        {
            SpawnType.Prey => 1,
            SpawnType.Predator => 3,
            _ => 0    // food / water anywhere
        };

        for (int i = 0; i < count; i++)
        {
            int idx = Random.Range(0, prefabs.Count);
            Vector3 pos = GetValidSpawnPosition(prefabs[idx], quadrant);
            if (pos == Vector3.positiveInfinity) continue;

            Quaternion rot = Quaternion.Euler(0, Random.Range(0f, 360f), 0);
            Instantiate(prefabs[idx], pos, rot, parent);
        }
    }

    void Spawn(GameObject prefab, int count, SpawnType type)
    {
        if (prefab == null || count <= 0) return;

        Transform parent = GetParent(type);
        int quadrant = (type == SpawnType.Predator) ? 3 :
                       (type == SpawnType.Prey) ? 1 : 0;

        for (int i = 0; i < count; i++)
        {
            Vector3 pos = GetValidSpawnPosition(prefab, quadrant);
            if (pos == Vector3.positiveInfinity) continue;
            Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
            Instantiate(prefab, pos, rot, parent);
        }
    }

    private IEnumerator<float> SpawnFoodRoutine()
    {
        float checkInterval = 2f;
        float elapsed = 0f;

        while (true)
        {
            yield return Timing.WaitForSeconds(Mathf.Min(checkInterval, foodSpawnInterval - elapsed));
            elapsed += checkInterval;

            int preyCount = EcosystemManager.Instance.CumulativeData.currentPreyCount;
            int target = Mathf.CeilToInt(preyCount * targetFoodPerPrey);

            if (activeFood < target)
            {
                int toSpawn = Mathf.Max(foodSpawnAmount, target - activeFood);
                Spawn(foodPrefabs, toSpawn, SpawnType.Food);
            }

            if (elapsed >= foodSpawnInterval)
                elapsed = 0f;
        }
    }

    private IEnumerator<float> SpawnWaterRoutine()
    {
        float checkInterval = 2f;
        float elapsed = 0f;

        while (true)
        {
            yield return Timing.WaitForSeconds(Mathf.Min(checkInterval, waterSpawnInterval - elapsed));
            elapsed += checkInterval;

            int preyCount = EcosystemManager.Instance.CumulativeData.currentPreyCount;
            int target = Mathf.CeilToInt(preyCount * targetWaterPerPrey);

            if (activeWater < target)
            {
                int toSpawn = Mathf.Max(waterSpawnAmount, target - activeWater);
                Spawn(waterPrefab, toSpawn, SpawnType.Water);
            }

            if (elapsed >= waterSpawnInterval)
                elapsed = 0f;
        }
    }

    public void Reinitialise()
    {
        Destroy(PreyParent);
        Destroy(PredatorParent);
        Destroy(FoodParent);
        Destroy(WaterParent);
        Timing.KillCoroutines(foodSpawnHandle);
        Timing.KillCoroutines(waterSpawnHandle);
        Start();               // fresh start
    }

    Transform GetParent(SpawnType type)
    {
        return type switch
        {
            SpawnType.Food => FoodParent.transform,
            SpawnType.Water => WaterParent.transform,
            SpawnType.Prey => PreyParent.transform,
            SpawnType.Predator => PredatorParent.transform,
            _ => new GameObject("ErrorSpawn").transform,
        };
    }

    static readonly Collider[] probeHits = new Collider[16];   // tweak size as needed
    Vector3 GetValidSpawnPosition(GameObject prefab, int quadrant = 0)
    {
        if (!spawnInQuadrants) quadrant = 0;
        float radius = checkRadius * Mathf.Max(prefab.transform.localScale.x,
                                               prefab.transform.localScale.y,
                                               prefab.transform.localScale.z);

        for (int attempt = 0; attempt < maxSpawnAttempts; attempt++)
        {
            Vector3 pos = EcosystemManager.Instance.GetSpawnPosition(quadrant);
            pos.y = prefab.transform.localScale.y;

            int hitCount = Physics.OverlapSphereNonAlloc(
                pos, radius, probeHits, obstacleMask, QueryTriggerInteraction.Collide);

            bool blocked = false;
            for (int i = 0; i < hitCount; i++)
            {
                Collider c = probeHits[i];
                if (!c || string.IsNullOrEmpty(c.tag)) continue;
                if (blockingTags.Contains(c.tag)) { blocked = true; break; }
            }

            if (!blocked) return pos;
        }

        CustomLogger.LogWarning($"[SpawnerManager] Could not place {prefab.name} in quadrant {quadrant}");
        return Vector3.positiveInfinity;
    }
}


--- FILE: Environment\SustainedConsumable.cs ---
using UnityEngine;

[DisallowMultipleComponent]
public class SustainedConsumable : MonoBehaviour
{
    public enum Type { Food, Water, Prey }

    [Header("Consumption Type")]
    public Type consumableType;
    [SerializeField] private ResourceBar resourceBar;

    [Header("Value Settings")]
    public float totalValue = 3f;
    public float remainingValue;
    public float tickInterval = 0.2f;

    [Header("Timing")]
    public float duration = 1f;

    [HideInInspector] public float valuePerTick;
    [HideInInspector] public int totalTicks;

    private void Awake()
    {
        InitializeValues();
        resourceBar = GetComponentInChildren<ResourceBar>();
        resourceBar.SetConsumable(this);

        if (consumableType == Type.Food)
            SpawnerManager.Instance.OnFoodSpawned();
        else if (consumableType == Type.Water)
            SpawnerManager.Instance.OnWaterSpawned();
    }

    public void InitializeValues()
    {
        remainingValue = totalValue;
        if (tickInterval <= 0.01f) tickInterval = 0.2f;
        if (duration <= 0f) duration = 1f;

        totalTicks = Mathf.Max(1, Mathf.RoundToInt(duration / tickInterval));
        valuePerTick = totalValue / totalTicks;

        if (consumableType == Type.Prey)
        {
            duration = 2f;
            if (TryGetComponent<PreyAgent>(out var sc))
            {
                float biomass = sc.stats.CurrentSize;
                totalValue = Mathf.Clamp(biomass, 1f, 5f);
                duration = biomass * 2f;
            }
        }
    }

    /// <summary>
    /// Only for Prey, updating value based on size as animal grows
    /// </summary>
    public void UpdateFromSize(float newBiomass)
    {
        if (consumableType != Type.Prey) return;

        float clampedBiomass = Mathf.Clamp(newBiomass, 1f, 5f);
        float previousTotal = totalValue;
        float consumedFraction = 1f - (remainingValue / previousTotal);

        totalValue = clampedBiomass;
        duration = clampedBiomass * 2f;

        totalTicks = Mathf.Max(1, Mathf.RoundToInt(duration / tickInterval));
        valuePerTick = totalValue / totalTicks;

        remainingValue = totalValue * (1f - consumedFraction);
    }

    /// <summary>
    /// Consume a fixed amount. Returns how much was actually consumed.
    /// </summary>
    public float Consume(float amount)
    {
        float consumed = Mathf.Min(amount, remainingValue);
        if (consumed <= 0f) return 0f;

        remainingValue -= consumed;
        remainingValue = Mathf.Max(0f, remainingValue);

        if (remainingValue <= 0)
        {
            switch (consumableType)
            {
                case Type.Food:
                    EcosystemManager.Instance.CumulativeData.foodConsumed += 1;
                    SpawnerManager.Instance.OnFoodConsumed();
                    break;
                case Type.Water:
                    EcosystemManager.Instance.CumulativeData.waterConsumed += 1;
                    SpawnerManager.Instance.OnWaterConsumed();
                    break;
                case Type.Prey:
                    EcosystemManager.Instance.CumulativeData.animalKilled += 1;
                    break;
            }
        }

        return consumed;
    }
}


--- FILE: Utilities\CustomLogger.cs ---
using System;
using UnityEngine;
#if UNITY_EDITOR

public static class CustomLogger
{
    private static readonly bool isLoggingEnabled = false;
    public static void Log(object message)
    {
        if (isLoggingEnabled)
        {
            Debug.Log(message);
        }
    }

    public static void LogWarning(object message)
    {
        if (isLoggingEnabled)
        {
            Debug.LogWarning(message);
        }
    }

    public static void LogError(object message)
    {
        if (isLoggingEnabled)
        {
            Debug.LogError(message);
        }
    }

    public static void LogException(Exception exception)
    {
        if (isLoggingEnabled)
        {
            Debug.LogException(exception, null);
        }
    }
    
    public static void DrawRay(Vector3 start, Vector3 dir, Color color)
    {
        if (isLoggingEnabled)
        {
            Debug.DrawRay(start, dir, color);
        }
    }
}
#else
// In builds, the CustomLogger class exists but all methods are effectively no-ops.
// This prevents any potential compiler or runtime errors due to missing methods.
public static class CustomLogger
{
    public static void Log(object message) { }

    public static void LogWarning(object message) { }

    public static void LogError(object message) { }

    public static void LogException(Exception exception) { }

    public static void DrawRay(Vector3 start, Vector3 dir, Color color) { }
}
#endif


--- FILE: Utilities\GeneticUtility.cs ---
using UnityEngine;

public static class GeneticUtility
{
    public static float Blend(float a, float b, float mutationRange = 0.05f)
    {
        float baseValue = Mathf.Lerp(a, b, Random.value);
        return baseValue + Random.Range(-mutationRange, mutationRange);
    }

    public static AgentStats Inherit(AgentStats p1, AgentStats p2)
    {
        float sRange = Mathf.Clamp(Blend(p1.sightRange, p2.sightRange), 0.5f, 3f);
        return new AgentStats(
            Blend(p1.speed, p2.speed),
            Blend(p1.maxSize, p2.maxSize),
            sRange);
    }
}


--- FILE: Utilities\RewardUtility.cs ---
using Unity.MLAgents;
using UnityEngine;

public static class RewardUtility
{
    /// <summary>Reward for consuming food. Baseline: +0.2 for 0.1 units.</summary>
    public static void AddNutritionReward(Agent agent, float amount)
    {
        float scaled = 0.2f * amount / 0.1f;
        EcosystemManager.Instance.CumulativeData.totalRewardGiven += scaled;
        agent.AddReward(scaled);
    }

    /// <summary>Reward for drinking water. Baseline: +0.2 for 0.1 units.</summary>
    public static void AddWaterReward(Agent agent, float amount)
    {
        float scaled = 0.2f * amount / 0.1f;
        EcosystemManager.Instance.CumulativeData.totalRewardGiven += scaled;
        agent.AddReward(scaled);
    }

    /// <summary>Reward for predator consuming prey. Baseline: +5.0 for 0.6 units.</summary>
    public static void AddPredationReward(Agent agent, float amount)
    {
        float scaled = 3.0f * amount / 0.6f;
        EcosystemManager.Instance.CumulativeData.totalRewardGiven += scaled;
        agent.AddReward(scaled);
    }

    /// <summary>Reward for Mating. Baseline: +0.2 for delta.</summary>
    public static void AddMatingReward(Agent agent, float amount = 0.15f)
    {
        EcosystemManager.Instance.CumulativeData.totalRewardGiven += amount;
        EcosystemManager.Instance.CumulativeData.partialMatingReward += amount;
        agent.AddReward(amount);
    }
    /// <summary>Reward for Mating. Baseline: +5 for success.</summary>
    public static void AddMatingSuccessReward(Agent agent, float amount = 5f)
    {
        EcosystemManager.Instance.CumulativeData.totalRewardGiven += amount;
        EcosystemManager.Instance.CumulativeData.totalMating++;
        agent.AddReward(amount);
    }

    /// <summary>Negative reward for being hungry or thirsty each frame. Penalty scales with deficiency.</summary>
    public static void ApplyVitalityReward(Agent agent, float hunger, float thirst)
    {
        // --- Reward Case: healthy levels ---
        if (hunger > 0.7f && thirst > 0.7f)
        {
            float reward = (hunger - 0.7f) + (thirst - 0.7f); // max theoretical: (1.0 - 0.7) * 2 = 0.6
            float scaledReward = Mathf.Clamp(reward, 0f, 0.1f) * Time.fixedDeltaTime;

            EcosystemManager.Instance.CumulativeData.totalRewardGiven += scaledReward;
            agent.AddReward(scaledReward);
        }
        // --- Penalty Case: undernourished or dehydrated ---
        else
        {
            float penalty = ComputePenalty(hunger) + ComputePenalty(thirst);  // max ~ -0.2
            float scaledPenalty = Mathf.Clamp(penalty, -0.1f, 0f) * Time.fixedDeltaTime;

            EcosystemManager.Instance.CumulativeData.totalPenaltyGiven += Mathf.Abs(scaledPenalty);
            agent.AddReward(scaledPenalty);
        }
    }

    public static void AddDeathPenalty(Agent agent)
    {
        EcosystemManager.Instance.CumulativeData.totalPenaltyGiven += 1f;
        agent.AddReward(-1f);
    }

    public static void AddCrowdedPenalty(Agent agent, int count)
    {
        float penalty = Mathf.Clamp01(count / 6f) * 0.05f;  // caps at -0.05
        EcosystemManager.Instance.CumulativeData.totalPenaltyGiven += penalty;
        EcosystemManager.Instance.CumulativeData.crowdingPenalty += penalty;
        agent.AddReward(-penalty);
    }

    /// <summary>Flat death penalty. Called once on death.</summary>
    public static void AddWallHitPenalty(Agent agent)
    {
        EcosystemManager.Instance.CumulativeData.totalPenaltyGiven += 0.5f;
        agent.AddReward(-0.5f);
    }

    private static float ComputePenalty(float value)
    {
        if (value >= 0.7f) return 0f;
        if (value >= 0.3f) return -0.0025f * ((0.7f - value) / 0.1f);
        return -0.01f * ((0.3f - value) / 0.1f);
    }
}


--- FILE: Utilities\Stats.cs ---
using Unity.MLAgents;

public static class Stats
{
    static readonly StatsRecorder SR = Academy.Instance.StatsRecorder;

    public static void RecordSurvival(int alive)
        => SR.Add("Environment/Alive", alive, StatAggregationMethod.MostRecent);

    public static void RecordMeanAge(float meanAge)
        => SR.Add("Population/MeanAge", meanAge, StatAggregationMethod.MostRecent);

    public static void RecordEpisodeReturn(float ret)
        => SR.Add("Episode/Return", ret, StatAggregationMethod.MostRecent);
}


--- FILE: Utilities\TagMask.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditorInternal;
#endif

[Serializable]
public class TagMask
{
    [SerializeField]
    private List<string> selectedTags = new List<string>();

    private HashSet<string> _tagSet;

    public bool Contains(string tag)
    {
        EnsureCache();
        return _tagSet.Contains(tag);
    }

    public string[] GetSelectedTags()
    {
        return selectedTags.ToArray();
    }

    public void SetSelectedTags(string[] tags)
    {
        selectedTags = new List<string>(tags);
        _tagSet = null; // reset cache
    }

    private void EnsureCache()
    {
        _tagSet ??= new HashSet<string>(selectedTags);
    }
}

#if UNITY_EDITOR

[CustomPropertyDrawer(typeof(TagMask))]
public class TagMaskDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        var tagListProp = property.FindPropertyRelative("selectedTags");
        string[] allTags = InternalEditorUtility.tags;

        int currentMask = 0;
        for (int i = 0; i < allTags.Length; i++)
        {
            if (tagListProp.Contains(allTags[i]))
                currentMask |= 1 << i;
        }

        int newMask = EditorGUI.MaskField(position, label, currentMask, allTags);
        if (newMask != currentMask)
        {
            tagListProp.ClearArray();
            for (int i = 0; i < allTags.Length; i++)
            {
                if ((newMask & (1 << i)) != 0)
                {
                    int index = tagListProp.arraySize;
                    tagListProp.InsertArrayElementAtIndex(index);
                    tagListProp.GetArrayElementAtIndex(index).stringValue = allTags[i];
                }
            }
        }
    }
}

public static class SerializedPropertyExtensions
{
    public static bool Contains(this SerializedProperty list, string value)
    {
        for (int i = 0; i < list.arraySize; i++)
        {
            if (list.GetArrayElementAtIndex(i).stringValue == value)
                return true;
        }
        return false;
    }
}
#endif

--- FILE: Utilities\Telemetry.cs ---
using System.IO;
using UnityEngine;

public class Telemetry : Singleton<Telemetry>
{
    private string csvPath;
    private StreamWriter writer;
    private EpisodeMetrics lastRecordedData;
    private double episodeStartTime = 0.0;

    private void Start()
    {
        int suffix = -1;
        #if UNITY_EDITOR
        string rootPath = Path.GetFullPath(Path.Combine(Application.dataPath, "../"));
        #else
        string rootPath = Path.GetFullPath(Path.Combine(Application.dataPath, "../../"));
        int pid = System.Diagnostics.Process.GetCurrentProcess().Id;
        suffix = pid;
        #endif

        string telemetryDir = Path.Combine(rootPath, "Assets", "Telemetry");

        if (!Directory.Exists(telemetryDir))
            Directory.CreateDirectory(telemetryDir);
        string environmentDir = Path.Combine(telemetryDir, EcosystemManager.Instance.Environment.name);
        if (!Directory.Exists(environmentDir))
            Directory.CreateDirectory(environmentDir);

        if(suffix==-1)
        csvPath = Path.Combine(environmentDir, $"eco-log-{System.DateTime.Now:yyyyMMdd_HHmm}.csv");
        else
        csvPath = Path.Combine(environmentDir, $"eco-log-{System.DateTime.Now:yyyyMMdd_HHmm}_{suffix}.csv");
        writer = new StreamWriter(csvPath);

        writer.WriteLine("episode,startTime,endTime,aliveTime," +
                         "totalRewardGiven,totalPenaltyGiven,crowdingPenalty," +
                         "totalPreySpawned,totalPredatorsSpawned," +
                         "foodConsumed,waterConsumed," +
                         "totalMating,partialMatingReward," +
                         "animalKilled,reachedLifeEnd,diedFromHunger,diedFromThirst");
        writer.Flush(); // ✅ Force write to disk

        Debug.Log($"[Telemetry] Logging to: {csvPath}");
    }

    public void OnEpisodeStart()
    {
        episodeStartTime = Time.timeAsDouble;
    }

    public void OnEpisodeEnd(EpisodeMetrics snapshot)
    {
        double end = Time.timeAsDouble;

        // First episode → log raw snapshot
        if (lastRecordedData == null)
        {
            lastRecordedData = snapshot.Clone();
            writer.WriteLine($"{snapshot.totalEpisodes},{episodeStartTime},{end:F2},{end - episodeStartTime:F2}," +
                             $"{snapshot.totalRewardGiven:F3}," +
                             $"{snapshot.totalPenaltyGiven:F3}," +
                             $"{snapshot.crowdingPenalty:F3}," +
                             $"{snapshot.totalPreySpawned}," +
                             $"{snapshot.totalPredatorsSpawned}," +
                             $"{snapshot.foodConsumed}," +
                             $"{snapshot.waterConsumed}," +
                             $"{snapshot.totalMating}," +
                             $"{snapshot.partialMatingReward:F3}," +
                             $"{snapshot.animalKilled}," +
                             $"{snapshot.reachedLifeEnd}," +
                             $"{snapshot.diedFromHunger}," +
                             $"{snapshot.diedFromThirst}");
        }
        else
        {
            double aliveTime = end - episodeStartTime;
            writer.WriteLine($"{snapshot.totalEpisodes},{episodeStartTime:F2},{end:F2},{aliveTime:F2}," +
                             $"{(snapshot.totalRewardGiven - lastRecordedData.totalRewardGiven):F3}," +
                             $"{(snapshot.totalPenaltyGiven - lastRecordedData.totalPenaltyGiven):F3}," +
                             $"{(snapshot.crowdingPenalty - lastRecordedData.crowdingPenalty):F3}," +
                             $"{snapshot.totalPreySpawned - lastRecordedData.totalPreySpawned}," +
                             $"{snapshot.totalPredatorsSpawned - lastRecordedData.totalPredatorsSpawned}," +
                             $"{snapshot.foodConsumed - lastRecordedData.foodConsumed}," +
                             $"{snapshot.waterConsumed - lastRecordedData.waterConsumed}," +
                             $"{snapshot.totalMating - lastRecordedData.totalMating}," +
                             $"{(snapshot.partialMatingReward - lastRecordedData.partialMatingReward):F3}," +
                             $"{snapshot.animalKilled - lastRecordedData.animalKilled}," +
                             $"{snapshot.reachedLifeEnd - lastRecordedData.reachedLifeEnd}," +
                             $"{snapshot.diedFromHunger - lastRecordedData.diedFromHunger}," +
                             $"{snapshot.diedFromThirst - lastRecordedData.diedFromThirst}");
        }

        lastRecordedData = snapshot.Clone(); // move reference forward
        writer.Flush();
    }

    protected override void OnDestroy()
    {
        base.OnDestroy();
        writer?.Close();
    }

    public EpisodeMetrics GetLastSnapshot()
    {
        return lastRecordedData;
    }
}
